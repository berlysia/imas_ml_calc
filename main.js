// Generated by CoffeeScript 1.7.1
var Idol, basePath, content, effectBoard, effectFactory, effectParse, getEffect, irregularEffect,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

basePath = "http://berlysia.github.io/imas_ml/millionlive_";

effectFactory = function(base, step) {
  return function(level) {
    level -= level < 10 ? 1 : 0;
    return base + step * level;
  };
};

irregularEffect = function(base, step) {
  return function(level) {
    if (level < 3) {
      level -= 1;
    }
    if (10 <= level) {
      level += 1;
    }
    return base + step * level;
  };
};

effectBoard = {
  self: {
    one: {
      1: effectFactory(0.18, 0.09),
      2: effectFactory(0.36, 0.09),
      3: effectFactory(0.72, 0.09),
      4: effectFactory(0, 0)
    },
    both: {
      1: effectFactory(0.09, 0.045),
      2: effectFactory(0.18, 0.045),
      3: effectFactory(0.36, 0.045),
      4: effectFactory(0, 0)
    }
  },
  singleRegion: {
    one: {
      1: effectFactory(0.05, 0.01),
      2: effectFactory(0.10, 0.01),
      3: effectFactory(0.13, 0.01),
      4: irregularEffect(0.15, 0.01)
    },
    both: {
      1: effectFactory(0.02, 0.01),
      2: effectFactory(0.04, 0.01),
      3: effectFactory(0.08, 0.01),
      4: effectFactory(0.12, 0.01)
    }
  },
  allRegion: {
    one: {
      1: effectFactory(0.02, 0.01),
      2: effectFactory(0.04, 0.01),
      3: effectFactory(0.08, 0.01),
      4: effectFactory()
    },
    both: {
      1: effectFactory(0.01, 0.01),
      2: effectFactory(0.02, 0.01),
      3: effectFactory(),
      4: effectFactory()
    }
  }
};

effectParse = function(serial, target) {
  switch (target) {
    case "other":
      return (serial >> 13) & 1;
    case "vocal":
      return (serial >> 12) & 1;
    case "dance":
      return (serial >> 11) & 1;
    case "visual":
      return (serial >> 10) & 1;
    case "targetPlayer":
      return (serial >> 9) & 1;
    case "targetArea":
      return (serial >> 6) & 7;
    case "apActive":
      return (serial >> 5) & 1;
    case "dpActive":
      return (serial >> 4) & 1;
    case "upOrDown":
      return (serial >> 3) & 1;
    case "scale":
      return serial & 7;
    default:
      return null;
  }
};

getEffect = function(serial, level) {
  var eff, firstKey, secondKey, target;
  if (level < 1 || 20 < level) {
    return {
      ap: 0,
      dp: 0
    };
  }
  if (effectParse(serial, "other") === 1 || effectParse(serial, "targetPlayer") === 0 || effectParse(serial, "upOrDown") === 0) {
    console.log("rejected", effectParse(serial, "other"), effectParse(serial, "targetPlayer"), effectParse(serial, "upOrDown"));
    return {
      ap: 0,
      dp: 0
    };
  } else {
    target = [];
    if ((effectParse(serial, "vocal") & effectParse(serial, "dance") & effectParse(serial, "visual")) === 0) {
      firstKey = "singleRegion";
      if (effectParse(serial, "vocal") === 1) {
        target.push("Vo");
      }
      if (effectParse(serial, "dance") === 1) {
        target.push("Da");
      }
      if (effectParse(serial, "visual") === 1) {
        target.push("Vi");
      }
    } else if (effectParse(serial, "targetArea") === 2) {
      firstKey = "allRegion";
      target.concat(["Vo", "Da", "Vi"]);
    } else if (effectParse(serial, "targetArea") === 7) {
      firstKey = "self";
      target.push("self");
    } else {
      console.log("othercase");
      return {
        ap: 0,
        dp: 0
      };
    }
    secondKey = effectParse(serial, "apActive") & effectParse(serial, "dpActive") ? "both" : "one";
    eff = effectBoard[firstKey][secondKey][effectParse(serial, "scale")](level) || [0];
    if (secondKey === "both") {
      return {
        ap: eff,
        dp: eff,
        target: target
      };
    } else {
      if (effectParse(serial, "apActive") === 1) {
        return {
          ap: eff,
          dp: 0,
          target: target
        };
      }
      if (effectParse(serial, "dpActive") === 1) {
        return {
          ap: 0,
          dp: eff,
          target: target
        };
      }
      return {
        ap: 0,
        dp: 0
      };
    }
  }
};

Idol = (function() {
  function Idol(id, name, region, cost, ap, dp, skill_name, skill_type, skill_serialized) {
    this.id = id;
    this.name = name;
    this.region = region;
    this.cost = cost;
    this.ap = ap;
    this.dp = dp;
    this.skill_name = skill_name;
    this.skill_type = skill_type;
    this.skill_serialized = skill_serialized;
    this.skill_level = 20;
    this.shinai = 500;
    this.ap = parseInt(this.ap);
    this.dp = parseInt(this.dp);
    this.cost = parseInt(this.cost);
    if (this.id === 1e5) {
      this.skill_serialized = 1e5;
    }
    this.skill_effect = getEffect(this.skill_serialized, this.skill_level);
    this.skill_activated = false;
    this.editable = this.id === 1e5;
    this.renkei_0 = false;
    this.renkei_1 = false;
    this.renkei_2 = false;
  }

  return Idol;

})();

content = $(function() {
  var view;
  return view = new Vue({
    el: "#calc",
    data: {
      roungeBonus: {
        ap: 0.02,
        dp: 0.02
      },
      renkei: [
        {
          ap: 0.03,
          dp: 0
        }, {
          ap: 0.01,
          dp: 0.01
        }, {
          ap: 0.02,
          dp: 0
        }
      ],
      idolList: {},
      activeIDs: [],
      activeNames: [],
      loaded: [],
      frontMember: [],
      supportMember: [],
      idolFactory: {
        region: "--",
        rarity: "--",
        id: 1e5
      },
      result: {
        front: [],
        support: [],
        sum: 0
      }
    },
    computed: {
      percost: function() {
        return this.$data.supportMember.map(function(idol) {
          return ((parseInt(idol.ap) + parseInt(idol.dp)) / idol.cost).toFixed(2);
        });
      }
    },
    methods: {
      preload: function(reg, rar) {
        var prop;
        prop = reg + "_" + rar;
        console.log(this.$data.loaded, reg, rar);
        if (!(prop in this.$data.loaded)) {
          return $.get(basePath + prop + ".json").then((function(_this) {
            return function(d, s) {
              var id, idol, _results;
              console.log("loaded:", s, d);
              _this.$data.loaded.push(prop);
              _this.$data.activeIDs = [];
              _this.$data.activeNames = [];
              _results = [];
              for (id in d) {
                idol = d[id];
                _this.$data.activeIDs.push(id);
                _this.$data.activeNames.push(idol["カード名"]);
                _results.push(_this.$data.idolList[id] = new Idol(idol["カードID"], idol["カード名"], idol["属性"], idol["コスト"], idol["MAX AP"], idol["MAX DP"], idol["スキル"], idol["効果"], idol["skill_serialized"]));
              }
              return _results;
            };
          })(this));
        } else {
          return $.Deferred();
        }
      },
      preloadByFormChange: function() {
        var rar, reg;
        console.log("formchange detected");
        reg = this.$data.idolFactory.region;
        rar = this.$data.idolFactory.rarity;
        if (reg === "--" || rar === "--") {
          return;
        }
        return this.preload(reg, rar);
      },
      addIdol: function(id, isSupport) {
        var member, tmp;
        console.log(id, this.$data.idolList[id]);
        member = isSupport ? this.$data.supportMember : this.$data.frontMember;
        tmp = null;
        if (typeof this.$data.idolList[id] !== "undefined") {
          tmp = $.extend(true, new Idol(), this.$data.idolList[id]);
        } else {
          tmp = new Idol(1e5);
        }
        member.push(tmp);
        return this;
      },
      removeIdol: function(idx, isSupport) {
        var member;
        member = isSupport ? this.$data.supportMember : this.$data.frontMember;
        member.$remove(idx);
        return this;
      },
      moveUpIdol: function(idx, reverse, isSupport) {
        var member, tmp;
        member = isSupport ? this.$data.supportMember : this.$data.frontMember;
        tmp = member.$remove(idx);
        member.splice(idx + (reverse ? 1 : -1), 0, tmp);
        return this;
      },
      calc: function() {
        var baseAP, baseDP, eff, front, i, idol, idol_i, idol_j, incAP, incDP, j, obj, ren, shinai, sum, support, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        front = [];
        support = [];
        _ref = this.$data.frontMember;
        for (i in _ref) {
          idol = _ref[i];
          shinai = (function() {
            switch (idol.shinai) {
              case 500:
                return 0.0825;
              case 400:
                return 0.0775;
              case 300:
                return 0.07;
              case 200:
                return 0.06;
              case 100:
                return 0.05;
              default:
                return 0;
            }
          })();
          baseAP = idol.ap + Math.ceil(idol.ap * shinai);
          baseDP = idol.dp + Math.ceil(idol.dp * shinai);
          incAP = Math.floor(baseAP * this.$data.roungeBonus.ap);
          incDP = Math.floor(baseDP * this.$data.roungeBonus.dp);
          _ref1 = this.$data.renkei;
          for (j in _ref1) {
            ren = _ref1[j];
            if (!idol["renkei_" + j]) {
              continue;
            }
            incAP += Math.floor(baseAP * ren.ap);
            incDP += Math.floor(baseDP * ren.dp);
          }
          front[i] = {
            baseAP: baseAP,
            baseDP: baseDP,
            incAP: incAP,
            incDP: incDP
          };
        }
        _ref2 = this.$data.frontMember;
        for (i in _ref2) {
          idol_i = _ref2[i];
          eff = idol_i.skill_effect;
          console.log(eff.target);
          _ref3 = this.$data.frontMember;
          for (j in _ref3) {
            idol_j = _ref3[j];
            if (!idol_j.skill_activated) {
              continue;
            }
            if (eff.target == null) {
              continue;
            }
            if (__indexOf.call(eff.target, "self") >= 0 && i !== j) {
              continue;
            }
            if (_ref4 = idol_j.region, __indexOf.call(eff.target, _ref4) < 0) {
              continue;
            }
            front[j].incAP += Math.floor(front[j].baseAP * eff.ap);
            front[j].incDP += Math.floor(front[j].baseDP * eff.dp);
          }
        }
        _ref5 = this.$data.supportMember;
        for (i in _ref5) {
          idol = _ref5[i];
          support[i] = {
            ap: Math.floor(idol.ap * 0.8),
            dp: Math.floor(idol.dp * 0.8)
          };
        }
        this.$data.result.front = front;
        this.$data.result.support = support;
        sum = 0;
        for (i in front) {
          obj = front[i];
          sum += obj.baseAP;
          sum += obj.baseDP;
          sum += obj.incAP;
          sum += obj.incDP;
        }
        for (i in support) {
          obj = support[i];
          sum += obj.ap;
          sum += obj.dp;
        }
        return this.$data.result.sum = sum;
      }
    }
  });
});
